# :link: 매서드 체이닝(Method Chaining)
> :boom: EP.01 `매서드 체이닝으로 코드를 구성한 이유가 있을까요?`  
> 
> 클래스 메서드를 체이닝으로 구현하여 호출하는 로직에서 예상치 못한 질문을 받았다.  
> 관성적으로 구현한 체이닝 패턴에 깊이 있게 고민해본 적 없는 부분이었다.  
> 본인이 작성한 코드를 설명하지 못한다는 사실에 얼굴이 화끈해졌다..:angry:  


##### Table of Contents
- [매서드 체이닝(Method Chaining)이란?](#🔗-매서드-체이닝method-chaining이란)  
- [체이닝(Chaining)의 이점](#👍-체이닝chaining의-이점)  
- [체이닝(Chaining)으로 발생 가능한 문제점](#👎-체이닝chaining으로-발생-가능한-문제점)  
- [오늘의 결론](#오늘의-결론)  
<br>

### :link: 매서드 체이닝(Method Chaining)이란?
``` javascript
// jQuery Method Chaining
$("#p1").css("color", "red").slideUp(2000).slideDown(2000);
```
객체지향프로그래밍(OOP)에서 <mark style="background-color:#dafbe1">매서드의 반환값을 다시 메서드의 인자로 사용하여 여러 매서드를 체인으로 호출하여 처리하는 패턴</mark>을 매서드 체이닝이라고 설명합니다. `jQuery`를 사용해 보신 분이라면 위와 같은 방식의 DOM 조작 코드가 익숙하실 것 같습니다. 그 외에도 `Promise`, `Array.prototype 매서드`, `빌더 패턴` 등 에서도 매서드 체이닝을 찾아 볼 수 있습니다.  
<br>

### :thumbsup: 체이닝(Chaining)의 이점
- 코드의 가독성이 향상되고 유지보수가 쉬워진다.
- 작업의 논리적 순서를 반영하는 직관적인 코드 작성이 가능하다.
- 중간에 결과 값을 임시 변수에 할당하는 불필요한 과정이 생략되어 코드의 중복성을 줄여준다.

### :thumbsdown: 체이닝(Chaining)으로 발생 가능한 문제점
- 길이가 긴 메서드 체인의 경우 오히려 가독성을 저해할 수 있으며 디버깅이 어려워진다.
- 체인의 순서를 변경하거나 중간에 다른 로직을 추가하기가 어렵다.
- 매서드 체인 내에서 오류가 발생하였을 경우 에러 핸들링이 어렵다.  
<br>

### 오늘의 결론
메서드 체이닝을 활용한 연속적인 제어는 작업의 논리적 순서를 반영하여 가독성 측면에서 이점을 가져갈 수 있습니다. 또한 임시 변수에 값을 할당하는 불필요한 과정에서 발생하는 불필요한 비용 소모를 줄일 수도 있습니다.  

우아하고 유용해 보이는 메서드 체이닝이지만 체인의 길이가 길어지면 오히려 가독성이 저하될 수 있으며 체인 중간에서 오류가 발생했을 때 원인을 파악하기 어려울 수 있습니다. 또한 하나의 논리적 단위로 묶여져 높아진 코드의 응집도는 코드의 유연한 변경을 어렵게 만들 수 있습니다.

결론적으로 연속적으로 테스트나 데이터를 필터링하고 조작하는 로직에서는 매서드 체이닝 패턴을 사용하는 것이 적절할 수 있습니다. 하지만 유연한 코드의 변경이 필요할 경우 혹은 오류 처리가 중요한 로직에서는 매서드 체이닝을 사용하기 보다 명시적인 오류 처리가 가능한 방식을 고려할 필요가 있을 것 같습니다.  
<br>

> :warning: tmi  
> 아마도 지금 다시 생각해 보면 내가 구현하고 싶었던 방식은 단순한 메서드의 세 이닝이 아닌 빌더 패턴(Builder Pattern)에 더 가깝지 않았을까 싶다. :eyes::question: 그 또한 적절한 방식인지는 구현하면서도 확인해 보자. :broken_heart:




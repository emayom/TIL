# 합병 정렬(Merge Sort)  

| `Algorithm` | :thumbsup: `Best` | `Avg` | :thumbsdown: `Worst` | `Space Complexity` | `stable`| `in-place` |
| :---      |   :----:  |   :----:   |   :----:   |   :----:   |   :----:   |   :----:   |
| 합병 정렬(Merge Sort) | O($n\\,log\\,n$) | O($n\\,log\\,n$) | O($n\\,log\\,n$) | O($n$) | :white_check_mark: | |

## 동작 원리 
> 이전에 구현한 버블 정렬, 삽입 정렬, 선택 정렬은 <u>2차 시간 복잡도</u>를 가지는 알고리즘으로 대용량의 정렬을 수행하기에는 적절하지 않다. 

합병 정렬은 **분할 정복 알고리즘**의 하나로 `분할`과 `합병`이 기본 동작 원리이다.   
주어진 배열을 반으로 나누는데 이때 나누어진 부분 배열들 각각의 길이가 1이 될 때까지 될 때까지 분할을 반복한다.  
리스트의 길이가 0 또는 1이면 정렬된 것으로 간주하며, 정렬된 부분 리스트들을 다시 합쳐가며 최종적으로 정렬된 배열을 완성한다. 


#### 분할 정복 알고리즘(Divide and Conquer Algorithm)이란?  
> 보통 재귀 함수를 통해 구현되며   
> 큰 문제를 작은 부분 문제들로 나누어가는 하향식(top-down) 접근 방법을 기반으로 한다. 

분할 정복 알고리즘은 `분할`, `정복`, `결합`의 과정으로 도식화할 수 있다. 

1. **분할** `Divide`  : 문제를 1개 이상의 부분 문제(subproblem)들로 나눈다. 
2. **정복** `Conquer`  : 부분 문제들을 재귀적으로 해결한다.  
3. **결합** `Combine` : 해결한 부분 문제의 답을 이용하여 전체 문제를 해결한다. 


- #### 병합 방식 
    - `2-way` 병합 : 2개의 부분 리스트를 하나로 병합한다. 
    - `n-way` 병합 : n개의 부분 리스트를 하나로 병합한다. 

- #### 재귀 함수 호출로 인한 오버헤드(Recursion Overhead)
    재귀함수 호출로 인한 `오버헤드`란 재귀 함수를 호출하면서 발생하는 추가적인 비용이나 부하를 나타낸다.  
    재귀 함수가 호출되면 호출 스택(Call Stack)에 각 호출에 대한 정보(해당 함수의 지역 변수, 매개 변수 등)를 스택 메모리에 저장하게 된다. 이는 호출이 깊어질 수록 메모리의 사용이 증가하며, 메모리 `오버헤드`를 초래하며 제한된 크기의 호출 스택에서 `스택 오버플로우`가 발생할 수 있다. 
    
    > 재귀 호출을 사용하지 않고 스택, 큐 등의 자료구조를 이용하여 분할 정복법을 구현하는 것도 가능하다. 

<br>

## 구현 
#### 의사코드(pseudo code)
- 정렬된 두 배열 합병을 담당할 [헬퍼 함수](#헬퍼-함수)를 먼저 작성한다.
    - 헬퍼 함수는 정렬된 두 배열이 주어지면 정렬된 하나의 배열로 리턴한다. 
    - `while`문으로 작성한다. 
- 배열의 길이가 1보다 작거나 같을 때까지 정렬할 배열을 반으로 나누는 과정을 반복한다. 
- 분해된 작은 배열들을 전체 배열의 길이로 돌아갈 때까지 다른 정렬된 배열과 합친다. 
- 분해된 배열이 다시 합쳐지면 정렬된 배열을 리턴한다. 

<br>

#### 헬퍼 함수 
```js
const merge = (array1, array2) => {
  const result = [];
  let i = 0;
  let j = 0;

  while (i < array1.length && j < array2.length) {
    if (array1[i] <= array2[j]) {
      result.push(array1[i]);
      i++;
    } else {
      result.push(array2[j]);
      j++;
    }
  }

  while (i < array1.length) {
    result.push(array1[i]);
    i++;
  }

  while (j < array2.length) {
    result.push(array2[j]);
    j++;
  }

  return result;
};
```
`2-way` 병합 방식으로 이미 정렬된 두 배열을 비교하며 **작은 값부터 정렬된 상태를 유지한 채** 새로운 배열에 더해준다.  
첫번째 `while`문의 비교하는 과정에서 인덱스 `i`, `j`값이 순차적으로 증가되며 새로운 배열로 정렬된다는 보장은 없다.   
이미 정렬된 상태에서 병합이 이루어졌기 때문에 처리되지 않은 나머지 배열들은 `result` 배열에 담긴 값보다 큰 값들으로 비교 없이 추가해도 정렬된 상태를 유지한다. 


```js
const merge = (array1, array2) => {
  // ... 공통 생략

  return [...result, ...array1.slice(i), ...array2.slice(j)];
};
```

나머지 정렬된 배열을 붙여주는 로직을 `while`문 대신 `spread` 연산자로 작성해 봤다.  
당연할지 모르겠지만 `1000 length`의 배열에서도 시간차가 있는 걸 보니 성능 면에서 좋지는 않을 듯하다! :no_good:


#### 합병 정렬 
```js
const array = [25, 4, 49, 22, 27, 32, 14, 7, 12, 40];

const mergeSort = (array) => {
  if (array.length <= 1) return array;

  const mid = Math.floor(array.length / 2);
  const left = mergeSort(array.slice(0, mid));
  const right =  mergeSort(array.slice(mid));

  return merge(left, right);
};
```
배열의 중간 값을 찾아 배열들 각각의 길이가 1이 될 때까지 될 때까지 반으로 분할하는 로직은 재귀 호출로 간단히 구현할 수 있다.   
부분 배열을 병합하는 로직은 미리 구현해둔 헬퍼 함수를 사용한다.  

결과적으로 재귀 호출을 통해 배열이 계속해서 작은 단위로 분할되고 정렬된 이후 최종적으로 `merge` 함수를 통해 합쳐지게 된다.  

```js
const array = [25, 4, 49, 22, 27, 32, 14, 7, 12, 40];

const mergeSort = (array) => {
  if (array.length <= 1) return array;

  const mid = Math.floor(array.length / 2);

  return merge(mergeSort(array.slice(0, mid)), mergeSort(array.slice(mid)));
};
```
`left`, `right` 배열을 별도로 생성하는 대신 `merge` 함수에 직접 전달하여 재귀적으로 병합하도록 수정했다!  
  동일한 과정으로 동작할까? 또한 위에서 언급한 [재귀 함수 호출로 인한 오버헤드](#재귀-함수-호출로-인한-오버헤드recursion-overhead)도 추가적으로 살펴봤다.  

> 아래는 크롬 개발자 도구를 통해 코드 스니펫을 저장하고 중단점을 지정하여 전반적인 로직의 흐름을 따라 호출 스택(Call Stack)을 확인한 내용이다. 

- **동일한 과정을 거쳐 동작한다.**  
    자바스크립트는 싱글 스레드 언어로 차례대로 한 번에 하나의 함수만 처리한다.   
    변경 전 후 모두 왼쪽 배열의 재귀 함수 호출이 종료되어 먼저 정렬이 된 이후 오른쪽 배열의 재귀 함수 호출이 처리되고 정렬된다.  
    처음 반으로 나누어진 두 배열이 정렬된 이후 마지막 `merge` 함수를 호출을 통해 정렬이 완료된다.

- **재귀 함수 호출로 인한 오버헤드**   
    주어진 배열을 반으로 나눈 후에, 각 부분 배열은 재귀적으로 `mergeSort` 함수를 호출했다.  
    재귀 호출은 `조건(Base Code)`을 만족할 때까지 반복되며, 호출된 함수들은 결과를 기다리기 위해 호출 스택에 체류한다.  
    `조건(Base Code)`을 만족하며 결과를 리턴하게 되면 더 이상의 재귀 호출은 이루어지지 않고 호출 스택에서 `pop`되며 하나씩 제거된다.  

<br>

## 시간 복잡도(Time Complexity)

합병 정렬의 시간 복잡도는 `Best`, `Average`, `Worst` 모든 경우에서 O($n\\,log\\,n$)이다.  

## 공간 복잡도(Space Complexity)
공간복잡도는 O($n$)으로 주어진 배열의 크기가 클수록 메모리에 더 많은 공간을 사용한다. 

<br>

## 결론 
합병 정렬은 이전에 구현한 2차 시간 복잡도를 가지는 정렬 알고리즘에 비해 추가적인 메모리 공간이 필요하지만,  
`Worst`의 경우에도 O($n\\,log\\,n$)의 시간 복잡도를 나타내는 일관된 성능을 보장한다.  
또한 데이터 크기가 커질수록 2차 시간 복잡도를 가지는 정렬 알고리즘보다 더욱 효율적이다.  

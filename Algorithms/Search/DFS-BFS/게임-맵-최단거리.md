---
title: "프로그래머스 - 게임 맵 최단거리"
category: "Algorithms"
tags: ["Algorithms", "Search", "BFS"]
date: 2024-11-04
last_modified_at: 2024-11-04
---

# 게임 맵 최단거리

<img src="https://img.shields.io/badge/-프로그래머스-1e2a3c" alt="프로그래머스"/> <img src="https://img.shields.io/badge/-Level 2-green" alt="Level 2"/> <img src="https://img.shields.io/badge/-BFS-mediumpurple" alt="BFS"/> 

- [문제 풀러 가기](https://school.programmers.co.kr/learn/courses/30/lessons/1844)

### 풀이 1:

```js
function solution(maps) {
    const m = maps.length;
    const n = maps[0].length;
    
    const dx = [0, 1, 0, -1];  
    const dy = [1, 0, -1, 0];  
    
    function bfs(matrix, start_x = 0, start_y = 0){
        const q = [ [start_x, start_y] ];
        const visited = Array.from({ length: m }).map(_ => Array.from({ length: n }).fill(0));  // 중복 방문 방지
        
        while(q.length){            
            const [x, y] = q.shift();

            if(visited[y][x] === 0){
                if(x === n-1 && y === m-1)  return matrix[y][x];

                visited[y][x] = 1;
            
                dx.forEach((_, i) => {
                    const nx = Math.min(Math.max(x + dx[i], 0), n-1);
                    const ny = Math.min(Math.max(y + dy[i], 0), m-1);
                    
                    if(matrix[ny][nx] && !visited[ny][nx]){
                        matrix[ny][nx] = matrix[y][x] + 1;
                        q.push([nx, ny]);
                    }
                });
            }
        }
        return -1;
    }

    return bfs(maps);
}
```

##### Review 

```
제한사항
- maps는 n x m 크기의 게임 맵의 상태가 들어있는 2차원 배열로, n과 m은 각각 1 이상 100 이하의 자연수입니다.
- n과 m은 서로 같을 수도, 다를 수도 있지만, n과 m이 모두 1인 경우는 입력으로 주어지지 않습니다.
- maps는 0과 1로만 이루어져 있으며, 0은 벽이 있는 자리, 1은 벽이 없는 자리를 나타냅니다.
- 처음에 캐릭터는 게임 맵의 좌측 상단인 (1, 1) 위치에 있으며, 상대방 진영은 게임 맵의 우측 하단인 (n, m) 위치에 있습니다.
```
